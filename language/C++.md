# 1. 预备知识
## 1.1 面向对象OOP
- 封装（Encapsulation）：封装是将数据和方法组合在一起，对外部隐藏实现细节，只公开对外提供的接口。这样可以提高安全性、可靠性和灵活性。
- 继承（Inheritance）：继承是从已有类中派生出新类，新类具有已有类的属性和方法，并且可以扩展或修改这些属性和方法。这样可以提高代码的复用性和可扩展性。
- 多态（Polymorphism）：多态是指同一种操作作用于不同的对象，可以有不同的解释和实现。它可以通过接口或继承实现，可以提高代码的灵活性和可读性。
- 抽象（Abstraction）：抽象是从具体的实例中提取共同的特征，形成抽象类或接口，以便于代码的复用和扩展。抽象类和接口可以让程序员专注于高层次的设计和业务逻辑，而不必关注底层的实现细节。

## 1.2 C++标准库
标准的 C++ 由三个重要部分组成：
1. 核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。
2. C++ 标准库，提供了大量的函数，用于操作文件、字符串等。
3. 标准模板库（STL），提供了大量的方法，用于操作数据结构等。

## 1.3 C++注释
- // - 一般用于单行注释。
    
- /* ... * /  - 一般用于多行注释。

## 1.4 数据类型
| 类型   | 关键字     | 位/字节 |
| ---- | ------- | ---- |
| 布尔型  | bool    |      |
| 字符型  | char    | 1    |
| 整型   | int     | 4    |
| 浮点型  | float   | 4    |
| 双浮点型 | double  | 8    |
| 无类型  | void    |      |
| 宽字符型 | wchar_t | 2or4 |
- 可以使用typedef声明一个新类型:
```
typedef type newname;
typedef int test;
test dis;
```

 - 枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。
	 - 第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2...
```
enum 枚举名{ 
     标识符[=整型常数], 
     标识符[=整型常数], 
... 
    标识符[=整型常数]
} 枚举变量;
```

### 1.4.1 类型转换 
类型转换：将一个数据类型的值转换为另一种数据类型的值，有以下四种转换：
- 静态转换（Static Cast）：将一种数据类型的值强制转换为另一种数据类型的值；
	- 静态转换不进行任何运行时类型检查，可能会报错；
```
int i = 10; 
float f = static_cast<float>(i);//int -> float
```
-  动态转换（Dynamic Cast）: 常用于将一个基类指针或引用转换为派生类指针或引用。动态转换在运行时进行类型检查，如果不能进行转换则返回空指针或引发异常
```
class Base {}; 
class Derived : public Base {}; 
Base* ptr_base = new Derived; 
Derived* ptr_derived = dynamic_cast<Derived*>(ptr_base); // 将基类指针转换为派生类指针
```